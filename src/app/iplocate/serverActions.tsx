"use server";

import { headers } from "next/headers";
import getErrorMessage from "@/app/errors";

import { token, awardBadge } from "../actions/akaActions";
import { encrypt, decrypt } from "@/util/aes";
import { getConfigParamValue } from "../actions/configParams";

export interface LoadResult {
  isValidSession: boolean;
  error?: string;
  encryptedToken?: string;
  country?: string;
  region?: string;
  city?: string;
}

export interface AwardBadgeResult {
  success: boolean;
  error?: string;
}

const aes_key = process.env.AES_KEY ?? "";

/**
 * Function to load session data using a session code.
 * @param code The session code to exchange for a token.
 * @returns A promise resolving to a LoadResult object.
 */
export const load = async (code: string): Promise<LoadResult> => {
  const loadResult: LoadResult = { isValidSession: false };

  if (code == "") {
    loadResult.error = "invalid code";
    return loadResult;
  }

  try {
    // exchange code for JSON web token
    const result = await token(code as string);

    if (result.error == "missing or invalid parameter") {
      let mesg = `Unable to get token using invalid code ${code}. Valid codes are generated by akaprofiles on redirect, and can expire.`;
      loadResult.error = mesg;
      return loadResult;
    }

    if (result.token != undefined && result.payload != undefined) {
      loadResult.isValidSession = true;

      // to prevent token being exposed client side, encrypt before returning
      // ecnrypted token will passed by client in subsequent server action calls
      if (aes_key == "") {
        const mesg = "AES_KEY environment variable not set";
        loadResult.error = mesg;
        return loadResult;
      }

      const encryptedToken = encrypt(aes_key, result.token);
      loadResult.encryptedToken = encryptedToken;

      const mesg = "Code successfully exchanged for token.";

      // parse config params
      const configParams = result.payload.configParams;
      const country = getConfigParamValue("Country", configParams);
      const region = getConfigParamValue("State/Prov", configParams);
      const city = getConfigParamValue("City", configParams);

      loadResult.country = country;
      loadResult.region = region;
      loadResult.city = city;
    }
  } catch (error) {
    const myError = error as Error;
    const mesg = `ERROR: ${myError.message}`;
    loadResult.error = myError.message;
    return loadResult;
  }
  return loadResult;
};

/**
 * Function to award an auto badge to a user.
 * @param encryptedToken The encrypted token containing user session information.
 * @returns A promise resolving to an AwardBadgeResult object.
 */
export const doAwardBadge = async (
  encryptedToken: string,
  awardData?: { country?: string; region?: string; city?: string }
): Promise<AwardBadgeResult> => {
  const plaintoken = decrypt(aes_key, encryptedToken);

  if (!plaintoken) {
    return { success: false, error: "could not decrypt token" };
  }

  try {
    const result = await awardBadge(plaintoken, awardData);
    if (result.success) {
      return { success: true };
    } else {
      const mesg = `badge not awarded: ${result.message}`;
      return { success: false, error: mesg };
    }
  } catch (posterror) {
    const error = posterror as Error;
    const mesg = error.message;
    return { success: false, error: mesg };
  }
};

export type Location = {
  "ip"?: string; // "1.1.1.1",
  "continent_name"?: string; // "North America",
  "country_code3"?: string; //"AUS",
  "country_name"?: string; // "Australia",
  "state_prov"?: string; // "Queensland",
  "city"?: string; // "South Brisbane",
  "message"?: string; // message on error
} | null;

export type IpLocResult = {
  success: boolean;
  message?: string;
  location?: Location;
};

export const getIpToLocation = async (): Promise<IpLocResult | null> => {
  const apiKey = process.env.IPGEOLOCATION_KEY;

  const ip = headers().get("x-forwarded-for"); // "75.155.176.254"
  // console.log(JSON.stringify(headers()));
  // console.log("IP: " + ip);

  // https://ipgeolocation.io/documentation/ip-geolocation-api.html
  const fields =
    "continent_code,continent_name,country_code3,country_name,state_prov,city";
  const url = `https://api.ipgeolocation.io/ipgeo?apiKey=${apiKey}&ip=${ip}&fields=${fields}`;

  try {
    const response = await fetch(url, { cache: "no-cache" });
    const location: Location = await response.json();
    if (location?.message) {
      // return error;
      return { success: false, message: location.message };
    }

    return { success: true, location: location };
  } catch (error) {
    console.error(`Error during ${url} request:`, error);
    return { success: false, message: getErrorMessage(error), location: null };
  }
};
